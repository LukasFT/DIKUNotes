
==================== FINAL INTERFACE ====================
2018-11-08 19:01:45.832535141 UTC

interface appm-0.0.0-bBoXP3Z3yF8cAWvQVfHOK:Utils [orphan module] 8043
  interface hash: 7ac96a52580c488d515b77beb23fc1b6
  ABI hash: 64658fcf41d296a2e90c8c567eb8db7b
  export-list hash: 5eb66a298ff304e448a448d129117718
  orphan hash: a74341d27a6f427d40f401a95346acd5
  flag hash: 1f596daf84c7527444ae092b33472386
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.allDiff
  Utils.getNameVerList
  Utils.isWellFormed
  Utils.merge
  Utils.mergeFolder
  Utils.ofSomeVersionIn
  Utils.requirementsOf
  Utils.sanityCheck
  Utils.satisfies
module dependencies: Defs
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  Defs c8776ec9639bd8739e47c30a97e82c26
  exports: 70baa90277fc6a1d9f89c14d3a2d95e0
  Constrs c0c7f7e044a5960d9dcc1d7679b95764
  DB 0e858781930e83bda69da5da2f88fc9e
  Database e605cad1cf2485e27892e093ede2b8a9
  PConstr a4165aea2f2f6f83a06790a6694f2369
  PName 4fd67735798f91f41256b7d11b8508d2
  Pkg 49fa6cbb2d53aa2b800f192f4268a0c2
  Sol 6fa7b2af0b6a1ae8c8e6d2ee2f37890f
  V 0a72cda81074e6d5c9a843c0cf32d0de
  VN d91ee0a2ffcf4c667c511bc41f908b4e
  Version 61141ba7ec719ef5a6c2d057138346c9
  deps 49fa6cbb2d53aa2b800f192f4268a0c2
  name 49fa6cbb2d53aa2b800f192f4268a0c2
  ver 49fa6cbb2d53aa2b800f192f4268a0c2
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Traversable 7ad4edb9184ea1ae8e73f6b94f115c8c
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
7e440e10d0a4d629a9f4cf7a60221ba0
  $fOrdVersion :: GHC.Classes.Ord Defs.Version
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Version
                  Defs.$fEqVersion
                  Utils.$fOrdVersion_$ccompare
                  Utils.$fOrdVersion_$c<
                  Utils.$fOrdVersion_$c<=
                  Utils.$fOrdVersion_$c>
                  Utils.$fOrdVersion_$c>=
                  Utils.$fOrdVersion_$cmax
                  Utils.$fOrdVersion_$cmin -}
035e8b37b7167d1b16a29348f1bd53df
  $fOrdVersion_$c< :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False -> Utils.$fOrdVersion_$c<= x y
                   GHC.Types.True -> GHC.Types.False }) -}
83b2324e741ce559cf4d02068d048bb3
  $fOrdVersion_$c<= :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
16a03f1137086bf8faa3d59f328aae80
  $fOrdVersion_$c> :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False
                   -> case Utils.$fOrdVersion_$c<= x y of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False }
                   GHC.Types.True -> GHC.Types.False }) -}
a371182710805a1c1494c2af18897750
  $fOrdVersion_$c>= :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False
                   -> case Utils.$fOrdVersion_$c<= x y of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False }
                   GHC.Types.True -> GHC.Types.True }) -}
cdebc247c8dcb1656f629959a0e3b7b9
  $fOrdVersion_$ccompare ::
    Defs.Version -> Defs.Version -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False
                   -> case Utils.$fOrdVersion_$c<= x y of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.LT }
                   GHC.Types.True -> GHC.Types.EQ }) -}
2498c510f5f3a1a35c744f96cbeb0648
  $fOrdVersion_$cmax :: Defs.Version -> Defs.Version -> Defs.Version
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case Utils.$fOrdVersion_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
983317f83364bff64fd2018c0d493887
  $fOrdVersion_$cmin :: Defs.Version -> Defs.Version -> Defs.Version
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case Utils.$fOrdVersion_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
eef3f0a7953f2b51e326aa10b095d049
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Utils.$trModule3 Utils.$trModule1) -}
ae7f7252d9b290ca533bfe0382625771
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule2) -}
6b13b6f9d0f9d99381a12c4e76c73aa1
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils"#) -}
fc34c6002777919df592de85388fbcbc
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule4) -}
160bcb365d191bd50bee6df889b55efd
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("appm-0.0.0-bBoXP3Z3yF8cAWvQVfHOK"#) -}
0b9c33e225ae7e50d3a14f836b88d95e
  $wmergeFolder ::
    Defs.Constrs
    -> Defs.PName -> Defs.PConstr -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,U><L,U(U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Defs.Constrs)
                   (ww :: Defs.PName)
                   (ww1 :: Defs.PConstr) ->
                 letrec {
                   $wgo :: [(Defs.PName, Defs.PConstr)]
                           -> (# [(Defs.PName, Defs.PConstr)], [(Defs.PName, Defs.PConstr)] #)
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                   = \ (w1 :: [(Defs.PName, Defs.PConstr)]) ->
                     case w1 of wild {
                       []
                       -> (# GHC.Types.[] @ (Defs.PName, Defs.PConstr),
                             GHC.Types.[] @ (Defs.PName, Defs.PConstr) #)
                       : y ys
                       -> case y of wild1 { (,) n2 ds ->
                          let {
                            w2 :: ([(Defs.PName, Defs.PConstr)], [(Defs.PName, Defs.PConstr)])
                            = case $wgo ys of ww2 { (#,#) ww3 ww4 -> (ww3, ww4) }
                          } in
                          case GHC.Base.eqString
                                 n2 `cast` (Defs.N:PName[0])
                                 ww `cast` (Defs.N:PName[0]) of wild2 {
                            GHC.Types.False
                            -> (# case w2 of wild3 { (,) ts fs -> ts },
                                  GHC.Types.:
                                    @ (Defs.PName, Defs.PConstr)
                                    wild1
                                    (case w2 of wild3 { (,) ts fs -> fs }) #)
                            GHC.Types.True
                            -> (# GHC.Types.:
                                    @ (Defs.PName, Defs.PConstr)
                                    wild1
                                    (case w2 of wild3 { (,) ts fs -> ts }),
                                  case w2 of wild3 { (,) ts fs -> fs } #) } } }
                 } in
                 case $wgo w of ww2 { (#,#) ww3 ww4 ->
                 case ww3 of wild {
                   []
                   -> GHC.Base.Just
                        @ [(Defs.PName, Defs.PConstr)]
                        (GHC.Types.: @ (Defs.PName, Defs.PConstr) (ww, ww1) w)
                   : ds ds1
                   -> case ds of wild1 { (,) ds2 c2 ->
                      case ds1 of wild2 {
                        []
                        -> case ww1 of wild3 { (,,) b1 lo1 hi1 ->
                           case c2 of wild4 { (,,) b2 lo2 hi2 ->
                           let {
                             $j :: Defs.Version -> GHC.Base.Maybe Defs.Constrs
                               <join 1> {- Arity: 1, Strictness: <S,U> -}
                             = \ (upper :: Defs.Version)[OneShot] ->
                               let {
                                 $j1 :: Defs.Version -> GHC.Base.Maybe Defs.Constrs
                                   <join 1> {- Arity: 1, Strictness: <S,U> -}
                                 = \ (lower :: Defs.Version)[OneShot] ->
                                   let {
                                     $j2 :: GHC.Base.Maybe Defs.Constrs <join 0>
                                     = GHC.Base.Just
                                         @ [(Defs.PName,
                                             (GHC.Types.Bool, Defs.Version, Defs.Version))]
                                         (GHC.Types.:
                                            @ (Defs.PName,
                                               (GHC.Types.Bool, Defs.Version, Defs.Version))
                                            (ww, (GHC.Classes.|| b1 b2, lower, upper))
                                            ww4)
                                   } in
                                   case GHC.Classes.$fEq[]_$c==
                                          @ Defs.VNum
                                          Defs.$fEqVNum
                                          lower `cast` (Defs.N:Version[0])
                                          upper `cast` (Defs.N:Version[0]) of wild5 {
                                     GHC.Types.False
                                     -> case Utils.$fOrdVersion_$c<= lower upper of wild6 {
                                          GHC.Types.False
                                          -> case b1 of wild7 {
                                               GHC.Types.False
                                               -> case b2 of wild8 {
                                                    GHC.Types.False -> $j2
                                                    GHC.Types.True
                                                    -> GHC.Base.Nothing @ Defs.Constrs }
                                               GHC.Types.True -> GHC.Base.Nothing @ Defs.Constrs }
                                          GHC.Types.True -> $j2 }
                                     GHC.Types.True
                                     -> case b1 of wild6 {
                                          GHC.Types.False
                                          -> case b2 of wild7 {
                                               GHC.Types.False -> $j2
                                               GHC.Types.True -> GHC.Base.Nothing @ Defs.Constrs }
                                          GHC.Types.True -> GHC.Base.Nothing @ Defs.Constrs } }
                               } in
                               case Utils.$fOrdVersion_$c<= lo1 lo2 of wild5 {
                                 GHC.Types.False -> $j1 lo1 GHC.Types.True -> $j1 lo2 }
                           } in
                           case Utils.$fOrdVersion_$c<= hi1 hi2 of wild5 {
                             GHC.Types.False -> $j hi2 GHC.Types.True -> $j hi1 } } }
                        : ipv ipv1 -> GHC.Base.Nothing @ Defs.Constrs } } } }) -}
63ba44dfc811f9d373bd27b5fba9fe33
  allDiff :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
97933eae742b739b1dd4a7922c4507b9
  getNameVerList :: Defs.Database -> [(Defs.PName, Defs.Version)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Defs.Database) ->
                 GHC.Base.build
                   @ (Defs.PName, Defs.Version)
                   (\ @ b1
                      (c :: (Defs.PName, Defs.Version) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ Defs.Pkg
                      @ b1
                      (GHC.Base.mapFB
                         @ (Defs.PName, Defs.Version)
                         @ b1
                         @ Defs.Pkg
                         c
                         Utils.getNameVerList1)
                      n
                      ds `cast` (Defs.N:Database[0]))) -}
8c14ff5d41d308736aafd903f6057e40
  getNameVerList1 :: Defs.Pkg -> (Defs.PName, Defs.Version)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (p :: Defs.Pkg) -> (Defs.name p, Defs.ver p)) -}
dec3eb277e5fc759e5ba8747362ac018
  isWellFormed :: [Defs.Constrs] -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (constraints :: [Defs.Constrs]) ->
                 case Utils.isWellFormed_go1 constraints of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ Defs.Constrs
                   GHC.Base.Just x
                   -> Utils.isWellFormed_go
                        x
                        (GHC.Types.[] @ (Defs.PName, Defs.PConstr)) }) -}
47be6c01e7a36e8b4ff0db87a3bf30ec
  isWellFormed_go ::
    [Defs.Constrs] -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
657886696c8be2549fef188f12e97123
  isWellFormed_go1 :: [Defs.Constrs] -> GHC.Base.Maybe [Defs.Constrs]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
73791c76f9e9f5b97e9d8711a1952f4e
  merge ::
    Defs.Constrs -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (c1 :: Defs.Constrs)
                   (ds :: [(Defs.PName, Defs.PConstr)]) ->
                 case ds of wild {
                   [] -> GHC.Base.Just @ Defs.Constrs c1
                   : ipv ipv1
                   -> case c1 of wild1 {
                        [] -> GHC.Base.Just @ Defs.Constrs wild
                        : ipv2 ipv3 -> Utils.merge_go wild1 wild } }) -}
35ba18ab59389dfe1b8e91b013a32544
  mergeFolder ::
    Defs.Constrs
    -> (Defs.PName, Defs.PConstr) -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,1*U(U,U(U,U,U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Constrs) (w1 :: (Defs.PName, Defs.PConstr)) ->
                 case w1 of ww { (,) ww1 ww2 -> Utils.$wmergeFolder w ww1 ww2 }) -}
894a22842959f682b3ef0de8d5d554d2
  merge_go ::
    [(Defs.PName, Defs.PConstr)]
    -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
18c18dcebb3d9c0694545946f9935020
  ofSomeVersionIn ::
    Defs.PName -> Defs.Database -> GHC.Base.Maybe Defs.Version
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (pname :: Defs.PName) (ds :: Defs.Database) ->
                 letrec {
                   go :: [Defs.Pkg] -> GHC.Base.Maybe Defs.Version
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds1 :: [Defs.Pkg]) ->
                     case ds1 of wild {
                       [] -> GHC.Base.Nothing @ Defs.Version
                       : y ys
                       -> case y of wild1 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                          case GHC.Base.eqString
                                 ds4 `cast` (Defs.N:PName[0])
                                 pname `cast` (Defs.N:PName[0]) of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True -> GHC.Base.Just @ Defs.Version ds5 } } }
                 } in
                 go ds `cast` (Defs.N:Database[0])) -}
01ca17b56e92eca039255969dd040b29
  requirementsOf ::
    Defs.Pkg -> [(Defs.PName, Defs.Version, Defs.Version)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 Utils.requirementsOf_go ww4 }) -}
910b840ee3a126faea5a55275994bdf6
  requirementsOf_go ::
    [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> [(Defs.PName, Defs.Version, Defs.Version)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
bc4bf5a306a83553acfc141c275fac90
  sanityCheck :: Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [(Defs.PName, Defs.PConstr)]) ->
                 case ds of wild {
                   [] -> Utils.sanityCheck1
                   : c cs
                   -> case cs of wild1 {
                        []
                        -> GHC.Base.Just
                             @ Defs.Constrs
                             (GHC.Types.:
                                @ (Defs.PName, Defs.PConstr)
                                c
                                (GHC.Types.[] @ (Defs.PName, Defs.PConstr)))
                        : ipv ipv1
                        -> case c of ww { (,) ww1 ww2 ->
                           Utils.$wmergeFolder wild1 ww1 ww2 } } }) -}
8e30d12b2f527c3770e0894d2f5ebb5f
  sanityCheck1 :: GHC.Base.Maybe [(Defs.PName, Defs.PConstr)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ [(Defs.PName, Defs.PConstr)]
                   (GHC.Types.[] @ (Defs.PName, Defs.PConstr))) -}
08adbc2ed2184e37d1239867c2b358e4
  satisfies :: Defs.Sol -> Defs.Constrs -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (ds :: Defs.Sol)
                   (ds1 :: [(Defs.PName, Defs.PConstr)]) ->
                 case ds1 of wild {
                   [] -> GHC.Types.True
                   : ipv ipv1
                   -> letrec {
                        go :: [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                              -> GHC.Types.Bool -> GHC.Types.Bool
                          <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                        = \ (ds2 :: [(Defs.PName,
                                      (GHC.Types.Bool, Defs.Version, Defs.Version))])
                            (eta :: GHC.Types.Bool) ->
                          case ds2 of wild1 {
                            [] -> eta
                            : y ys
                            -> case y of wild2 { (,) cn ds3 ->
                               case ds3 of wild3 { (,,) requires lo hi ->
                               case requires of wild4 {
                                 GHC.Types.False
                                 -> case eta of wild5 {
                                      GHC.Types.False -> go ys GHC.Types.False
                                      GHC.Types.True
                                      -> let {
                                           exit :: GHC.Types.Bool <join 0> = go ys GHC.Types.True
                                         } in
                                         let {
                                           exit1 :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         let {
                                           exit2 :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         let {
                                           exit3 :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         letrec {
                                           go1 :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                                             <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ (ds4 :: [(Defs.PName, Defs.Version)]) ->
                                             case ds4 of wild6 {
                                               [] -> exit
                                               : y1 ys1
                                               -> case y1 of wild7 { (,) sn sv ->
                                                  case GHC.Classes.$fEqModule_$s$c==
                                                         cn `cast` (Defs.N:PName[0])
                                                         sn `cast` (Defs.N:PName[0]) of wild8 {
                                                    GHC.Types.False -> go1 ys1
                                                    GHC.Types.True
                                                    -> case Utils.$fOrdVersion_$c<= lo sv of wild9 {
                                                         GHC.Types.False -> exit1
                                                         GHC.Types.True
                                                         -> case GHC.Classes.$fEq[]_$c==
                                                                   @ Defs.VNum
                                                                   Defs.$fEqVNum
                                                                   sv `cast` (Defs.N:Version[0])
                                                                   hi
                                                                     `cast`
                                                                   (Defs.N:Version[0]) of wild10 {
                                                              GHC.Types.False
                                                              -> case Utils.$fOrdVersion_$c<=
                                                                        sv
                                                                        hi of wild11 {
                                                                   GHC.Types.False -> exit2
                                                                   GHC.Types.True -> go1 ys1 }
                                                              GHC.Types.True -> exit3 } } } } }
                                         } in
                                         go1 ds }
                                 GHC.Types.True
                                 -> case eta of wild5 {
                                      GHC.Types.False -> go ys GHC.Types.False
                                      GHC.Types.True
                                      -> let {
                                           exit :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         let {
                                           exit1 :: GHC.Types.Bool <join 0> = go ys GHC.Types.True
                                         } in
                                         letrec {
                                           go1 :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                                             <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ (ds4 :: [(Defs.PName, Defs.Version)]) ->
                                             case ds4 of wild6 {
                                               [] -> exit
                                               : y1 ys1
                                               -> case y1 of wild7 { (,) sn sv ->
                                                  case GHC.Base.eqString
                                                         cn `cast` (Defs.N:PName[0])
                                                         sn `cast` (Defs.N:PName[0]) of wild8 {
                                                    GHC.Types.False -> go1 ys1
                                                    GHC.Types.True
                                                    -> case Utils.$fOrdVersion_$c<= lo sv of wild9 {
                                                         GHC.Types.False -> go1 ys1
                                                         GHC.Types.True
                                                         -> case GHC.Classes.$fEq[]_$c==
                                                                   @ Defs.VNum
                                                                   Defs.$fEqVNum
                                                                   sv `cast` (Defs.N:Version[0])
                                                                   hi
                                                                     `cast`
                                                                   (Defs.N:Version[0]) of wild10 {
                                                              GHC.Types.False
                                                              -> case Utils.$fOrdVersion_$c<=
                                                                        sv
                                                                        hi of wild11 {
                                                                   GHC.Types.False -> go1 ys1
                                                                   GHC.Types.True -> exit1 }
                                                              GHC.Types.True -> go1 ys1 } } } } }
                                         } in
                                         go1 ds } } } } }
                      } in
                      go wild GHC.Types.True }) -}
instance [safe] [orphan] GHC.Classes.Ord [Defs.Version]
  = Utils.$fOrdVersion
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

