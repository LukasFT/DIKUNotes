
==================== FINAL INTERFACE ====================
2018-11-08 19:01:48.228993242 UTC

interface main:Utils [orphan module] 8043
  interface hash: a6e093601a0e02a6aab173308c5f5179
  ABI hash: 7cf83227e593a77bfd11340782384c6f
  export-list hash: 1a5cae1c4720889ee4d936faefb0e28b
  orphan hash: 7f7c7efc398a91a57ef4b6975ca905b7
  flag hash: 8159db7c32bdb9b5583c3379f950f8b0
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.allDiff
  Utils.getNameVerList
  Utils.isWellFormed
  Utils.merge
  Utils.mergeFolder
  Utils.ofSomeVersionIn
  Utils.requirementsOf
  Utils.sanityCheck
  Utils.satisfies
module dependencies: Defs
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Traversable 7ad4edb9184ea1ae8e73f6b94f115c8c
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  Defs 939981403a64797c8d0fa3fbf484bbbe
  exports: c7af33238562f604e2baaf89a4270987
  Constrs 67ed1f0cbb9f7e339ca293c38a21e465
  DB b49c7dbde0a8d4b21e98f928363a906f
  Database 55a55788ca8541f4ef74a862bab369c7
  PConstr 3682d99f4b17fea3ed26cf03606b04f4
  PName 4511359dbcf04214c85540a57fb65f09
  Pkg 517307a9ca3c1f5e46b542ebf261be96
  Sol 16e05ea27be6e36e50158e24b50ca6e0
  V 9c1c145b1740d47ff450a730ad2d07fc
  VN 965ca6aa56109f751dad4686b47c7162
  Version e887542530e08af7f6e3809d845b18d6
  deps 517307a9ca3c1f5e46b542ebf261be96
  name 517307a9ca3c1f5e46b542ebf261be96
  ver 517307a9ca3c1f5e46b542ebf261be96
e79c57be753fd2711097535d7f419df1
  $fOrdVersion :: GHC.Classes.Ord Defs.Version
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Defs.Version
                  Defs.$fEqVersion
                  Utils.$fOrdVersion_$ccompare
                  Utils.$fOrdVersion_$c<
                  Utils.$fOrdVersion_$c<=
                  Utils.$fOrdVersion_$c>
                  Utils.$fOrdVersion_$c>=
                  Utils.$fOrdVersion_$cmax
                  Utils.$fOrdVersion_$cmin -}
f199e5e296d9dcf914930281213badc7
  $fOrdVersion_$c< :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False -> Utils.$fOrdVersion_$c<= x y
                   GHC.Types.True -> GHC.Types.False }) -}
70a18da138cdbf015e2882ed0aff6a19
  $fOrdVersion_$c<= :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
e8b73e626ef90bad246884059584d310
  $fOrdVersion_$c> :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False
                   -> case Utils.$fOrdVersion_$c<= x y of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False }
                   GHC.Types.True -> GHC.Types.False }) -}
f9c840ffdeddd8960b64e3d7f4f6ead5
  $fOrdVersion_$c>= :: Defs.Version -> Defs.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False
                   -> case Utils.$fOrdVersion_$c<= x y of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False }
                   GHC.Types.True -> GHC.Types.True }) -}
d0487c3955ec4d3447c793828614e760
  $fOrdVersion_$ccompare ::
    Defs.Version -> Defs.Version -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        x `cast` (Defs.N:Version[0])
                        y `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False
                   -> case Utils.$fOrdVersion_$c<= x y of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.LT }
                   GHC.Types.True -> GHC.Types.EQ }) -}
b7c134d663114f716353046ba9a76ca9
  $fOrdVersion_$cmax :: Defs.Version -> Defs.Version -> Defs.Version
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case Utils.$fOrdVersion_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
c4b13f6ea84d4c3257645909b169d513
  $fOrdVersion_$cmin :: Defs.Version -> Defs.Version -> Defs.Version
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Defs.Version) (y :: Defs.Version) ->
                 case Utils.$fOrdVersion_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
6e4cfbbe250611482ac08c6d558f4dce
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Utils.$trModule3 Utils.$trModule1) -}
6ea2ae0a946ba28d3e9a92ae079dc36e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule2) -}
c81636fcbf58b412e558c29d269dd105
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils"#) -}
48e9693c199df8b405168bfddb9c283b
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule4) -}
be56da26131302c822ff452d3bc5ec6f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
602cc7d394ab5a911bf8fb767857a7e9
  $wmergeFolder ::
    Defs.Constrs
    -> Defs.PName -> Defs.PConstr -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,U><L,U(U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Defs.Constrs)
                   (ww :: Defs.PName)
                   (ww1 :: Defs.PConstr) ->
                 letrec {
                   $wgo :: [(Defs.PName, Defs.PConstr)]
                           -> (# [(Defs.PName, Defs.PConstr)], [(Defs.PName, Defs.PConstr)] #)
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                   = \ (w1 :: [(Defs.PName, Defs.PConstr)]) ->
                     case w1 of wild {
                       []
                       -> (# GHC.Types.[] @ (Defs.PName, Defs.PConstr),
                             GHC.Types.[] @ (Defs.PName, Defs.PConstr) #)
                       : y ys
                       -> case y of wild1 { (,) n2 ds ->
                          let {
                            w2 :: ([(Defs.PName, Defs.PConstr)], [(Defs.PName, Defs.PConstr)])
                            = case $wgo ys of ww2 { (#,#) ww3 ww4 -> (ww3, ww4) }
                          } in
                          case GHC.Base.eqString
                                 n2 `cast` (Defs.N:PName[0])
                                 ww `cast` (Defs.N:PName[0]) of wild2 {
                            GHC.Types.False
                            -> (# case w2 of wild3 { (,) ts fs -> ts },
                                  GHC.Types.:
                                    @ (Defs.PName, Defs.PConstr)
                                    wild1
                                    (case w2 of wild3 { (,) ts fs -> fs }) #)
                            GHC.Types.True
                            -> (# GHC.Types.:
                                    @ (Defs.PName, Defs.PConstr)
                                    wild1
                                    (case w2 of wild3 { (,) ts fs -> ts }),
                                  case w2 of wild3 { (,) ts fs -> fs } #) } } }
                 } in
                 case $wgo w of ww2 { (#,#) ww3 ww4 ->
                 case ww3 of wild {
                   []
                   -> GHC.Base.Just
                        @ [(Defs.PName, Defs.PConstr)]
                        (GHC.Types.: @ (Defs.PName, Defs.PConstr) (ww, ww1) w)
                   : ds ds1
                   -> case ds of wild1 { (,) ds2 c2 ->
                      case ds1 of wild2 {
                        []
                        -> case ww1 of wild3 { (,,) b1 lo1 hi1 ->
                           case c2 of wild4 { (,,) b2 lo2 hi2 ->
                           let {
                             $j :: Defs.Version -> GHC.Base.Maybe Defs.Constrs
                               <join 1> {- Arity: 1, Strictness: <S,U> -}
                             = \ (upper :: Defs.Version)[OneShot] ->
                               let {
                                 $j1 :: Defs.Version -> GHC.Base.Maybe Defs.Constrs
                                   <join 1> {- Arity: 1, Strictness: <S,U> -}
                                 = \ (lower :: Defs.Version)[OneShot] ->
                                   let {
                                     $j2 :: GHC.Base.Maybe Defs.Constrs <join 0>
                                     = GHC.Base.Just
                                         @ [(Defs.PName,
                                             (GHC.Types.Bool, Defs.Version, Defs.Version))]
                                         (GHC.Types.:
                                            @ (Defs.PName,
                                               (GHC.Types.Bool, Defs.Version, Defs.Version))
                                            (ww, (GHC.Classes.|| b1 b2, lower, upper))
                                            ww4)
                                   } in
                                   case GHC.Classes.$fEq[]_$c==
                                          @ Defs.VNum
                                          Defs.$fEqVNum
                                          lower `cast` (Defs.N:Version[0])
                                          upper `cast` (Defs.N:Version[0]) of wild5 {
                                     GHC.Types.False
                                     -> case Utils.$fOrdVersion_$c<= lower upper of wild6 {
                                          GHC.Types.False
                                          -> case b1 of wild7 {
                                               GHC.Types.False
                                               -> case b2 of wild8 {
                                                    GHC.Types.False -> $j2
                                                    GHC.Types.True
                                                    -> GHC.Base.Nothing @ Defs.Constrs }
                                               GHC.Types.True -> GHC.Base.Nothing @ Defs.Constrs }
                                          GHC.Types.True -> $j2 }
                                     GHC.Types.True
                                     -> case b1 of wild6 {
                                          GHC.Types.False
                                          -> case b2 of wild7 {
                                               GHC.Types.False -> $j2
                                               GHC.Types.True -> GHC.Base.Nothing @ Defs.Constrs }
                                          GHC.Types.True -> GHC.Base.Nothing @ Defs.Constrs } }
                               } in
                               case Utils.$fOrdVersion_$c<= lo1 lo2 of wild5 {
                                 GHC.Types.False -> $j1 lo1 GHC.Types.True -> $j1 lo2 }
                           } in
                           case Utils.$fOrdVersion_$c<= hi1 hi2 of wild5 {
                             GHC.Types.False -> $j hi2 GHC.Types.True -> $j hi1 } } }
                        : ipv ipv1 -> GHC.Base.Nothing @ Defs.Constrs } } } }) -}
081ac93fa7727e144fad856eeca44715
  allDiff :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
7315cacba4dd82cb7d15a25c2b624805
  getNameVerList :: Defs.Database -> [(Defs.PName, Defs.Version)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Defs.Database) ->
                 GHC.Base.build
                   @ (Defs.PName, Defs.Version)
                   (\ @ b1
                      (c :: (Defs.PName, Defs.Version) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ Defs.Pkg
                      @ b1
                      (GHC.Base.mapFB
                         @ (Defs.PName, Defs.Version)
                         @ b1
                         @ Defs.Pkg
                         c
                         Utils.getNameVerList1)
                      n
                      ds `cast` (Defs.N:Database[0]))) -}
df494f605163551f36b553eb2d4c205b
  getNameVerList1 :: Defs.Pkg -> (Defs.PName, Defs.Version)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (p :: Defs.Pkg) -> (Defs.name p, Defs.ver p)) -}
b962b0ab44d43acf38ee9a48ce4ed20f
  isWellFormed :: [Defs.Constrs] -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (constraints :: [Defs.Constrs]) ->
                 case Utils.isWellFormed_go1 constraints of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ Defs.Constrs
                   GHC.Base.Just x
                   -> Utils.isWellFormed_go
                        x
                        (GHC.Types.[] @ (Defs.PName, Defs.PConstr)) }) -}
5a5d15d988abc4049445eed3952e0299
  isWellFormed_go ::
    [Defs.Constrs] -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
ca814bb3b52429d91c6d5607739e93ad
  isWellFormed_go1 :: [Defs.Constrs] -> GHC.Base.Maybe [Defs.Constrs]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8ad095fb645d08fd1e1f2c792fa95af7
  merge ::
    Defs.Constrs -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (c1 :: Defs.Constrs)
                   (ds :: [(Defs.PName, Defs.PConstr)]) ->
                 case ds of wild {
                   [] -> GHC.Base.Just @ Defs.Constrs c1
                   : ipv ipv1
                   -> case c1 of wild1 {
                        [] -> GHC.Base.Just @ Defs.Constrs wild
                        : ipv2 ipv3 -> Utils.merge_go wild1 wild } }) -}
d804a51491cc087b5905e7318e110d20
  mergeFolder ::
    Defs.Constrs
    -> (Defs.PName, Defs.PConstr) -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,1*U(U,U(U,U,U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Constrs) (w1 :: (Defs.PName, Defs.PConstr)) ->
                 case w1 of ww { (,) ww1 ww2 -> Utils.$wmergeFolder w ww1 ww2 }) -}
e69b021a176f15f7ef6e9479cef9958b
  merge_go ::
    [(Defs.PName, Defs.PConstr)]
    -> Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
99dba7572c70c3eb3610db92c76ecc40
  ofSomeVersionIn ::
    Defs.PName -> Defs.Database -> GHC.Base.Maybe Defs.Version
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (pname :: Defs.PName) (ds :: Defs.Database) ->
                 letrec {
                   go :: [Defs.Pkg] -> GHC.Base.Maybe Defs.Version
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds1 :: [Defs.Pkg]) ->
                     case ds1 of wild {
                       [] -> GHC.Base.Nothing @ Defs.Version
                       : y ys
                       -> case y of wild1 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                          case GHC.Base.eqString
                                 ds4 `cast` (Defs.N:PName[0])
                                 pname `cast` (Defs.N:PName[0]) of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True -> GHC.Base.Just @ Defs.Version ds5 } } }
                 } in
                 go ds `cast` (Defs.N:Database[0])) -}
eb21e0421572e827fdcec58c6d999e13
  requirementsOf ::
    Defs.Pkg -> [(Defs.PName, Defs.Version, Defs.Version)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 Utils.requirementsOf_go ww4 }) -}
04e9017fcad8ad528a49d243908de6d6
  requirementsOf_go ::
    [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> [(Defs.PName, Defs.Version, Defs.Version)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
82e7f162c15fa58e6c38df3d382cb232
  sanityCheck :: Defs.Constrs -> GHC.Base.Maybe Defs.Constrs
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [(Defs.PName, Defs.PConstr)]) ->
                 case ds of wild {
                   [] -> Utils.sanityCheck1
                   : c cs
                   -> case cs of wild1 {
                        []
                        -> GHC.Base.Just
                             @ Defs.Constrs
                             (GHC.Types.:
                                @ (Defs.PName, Defs.PConstr)
                                c
                                (GHC.Types.[] @ (Defs.PName, Defs.PConstr)))
                        : ipv ipv1
                        -> case c of ww { (,) ww1 ww2 ->
                           Utils.$wmergeFolder wild1 ww1 ww2 } } }) -}
19f4a322b139ab3a492c6638ad063b42
  sanityCheck1 :: GHC.Base.Maybe [(Defs.PName, Defs.PConstr)]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ [(Defs.PName, Defs.PConstr)]
                   (GHC.Types.[] @ (Defs.PName, Defs.PConstr))) -}
e893c3b79a06ee7589b6795fc84a5c57
  satisfies :: Defs.Sol -> Defs.Constrs -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (ds :: Defs.Sol)
                   (ds1 :: [(Defs.PName, Defs.PConstr)]) ->
                 case ds1 of wild {
                   [] -> GHC.Types.True
                   : ipv ipv1
                   -> letrec {
                        go :: [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                              -> GHC.Types.Bool -> GHC.Types.Bool
                          <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                        = \ (ds2 :: [(Defs.PName,
                                      (GHC.Types.Bool, Defs.Version, Defs.Version))])
                            (eta :: GHC.Types.Bool) ->
                          case ds2 of wild1 {
                            [] -> eta
                            : y ys
                            -> case y of wild2 { (,) cn ds3 ->
                               case ds3 of wild3 { (,,) requires lo hi ->
                               case requires of wild4 {
                                 GHC.Types.False
                                 -> case eta of wild5 {
                                      GHC.Types.False -> go ys GHC.Types.False
                                      GHC.Types.True
                                      -> let {
                                           exit :: GHC.Types.Bool <join 0> = go ys GHC.Types.True
                                         } in
                                         let {
                                           exit1 :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         let {
                                           exit2 :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         let {
                                           exit3 :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         letrec {
                                           go1 :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                                             <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ (ds4 :: [(Defs.PName, Defs.Version)]) ->
                                             case ds4 of wild6 {
                                               [] -> exit
                                               : y1 ys1
                                               -> case y1 of wild7 { (,) sn sv ->
                                                  case GHC.Classes.$fEqModule_$s$c==
                                                         cn `cast` (Defs.N:PName[0])
                                                         sn `cast` (Defs.N:PName[0]) of wild8 {
                                                    GHC.Types.False -> go1 ys1
                                                    GHC.Types.True
                                                    -> case Utils.$fOrdVersion_$c<= lo sv of wild9 {
                                                         GHC.Types.False -> exit1
                                                         GHC.Types.True
                                                         -> case GHC.Classes.$fEq[]_$c==
                                                                   @ Defs.VNum
                                                                   Defs.$fEqVNum
                                                                   sv `cast` (Defs.N:Version[0])
                                                                   hi
                                                                     `cast`
                                                                   (Defs.N:Version[0]) of wild10 {
                                                              GHC.Types.False
                                                              -> case Utils.$fOrdVersion_$c<=
                                                                        sv
                                                                        hi of wild11 {
                                                                   GHC.Types.False -> exit2
                                                                   GHC.Types.True -> go1 ys1 }
                                                              GHC.Types.True -> exit3 } } } } }
                                         } in
                                         go1 ds }
                                 GHC.Types.True
                                 -> case eta of wild5 {
                                      GHC.Types.False -> go ys GHC.Types.False
                                      GHC.Types.True
                                      -> let {
                                           exit :: GHC.Types.Bool <join 0> = go ys GHC.Types.False
                                         } in
                                         let {
                                           exit1 :: GHC.Types.Bool <join 0> = go ys GHC.Types.True
                                         } in
                                         letrec {
                                           go1 :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                                             <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ (ds4 :: [(Defs.PName, Defs.Version)]) ->
                                             case ds4 of wild6 {
                                               [] -> exit
                                               : y1 ys1
                                               -> case y1 of wild7 { (,) sn sv ->
                                                  case GHC.Base.eqString
                                                         cn `cast` (Defs.N:PName[0])
                                                         sn `cast` (Defs.N:PName[0]) of wild8 {
                                                    GHC.Types.False -> go1 ys1
                                                    GHC.Types.True
                                                    -> case Utils.$fOrdVersion_$c<= lo sv of wild9 {
                                                         GHC.Types.False -> go1 ys1
                                                         GHC.Types.True
                                                         -> case GHC.Classes.$fEq[]_$c==
                                                                   @ Defs.VNum
                                                                   Defs.$fEqVNum
                                                                   sv `cast` (Defs.N:Version[0])
                                                                   hi
                                                                     `cast`
                                                                   (Defs.N:Version[0]) of wild10 {
                                                              GHC.Types.False
                                                              -> case Utils.$fOrdVersion_$c<=
                                                                        sv
                                                                        hi of wild11 {
                                                                   GHC.Types.False -> go1 ys1
                                                                   GHC.Types.True -> exit1 }
                                                              GHC.Types.True -> go1 ys1 } } } } }
                                         } in
                                         go1 ds } } } } }
                      } in
                      go wild GHC.Types.True }) -}
instance [safe] [orphan] GHC.Classes.Ord [Defs.Version]
  = Utils.$fOrdVersion
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

