
==================== FINAL INTERFACE ====================
2018-11-08 19:04:12.733786618 UTC

interface main:Properties 8043
  interface hash: e70f1b12a243f3caf3ccd6d873d9f59d
  ABI hash: ea471877b75a281a03c978c1796403e5
  export-list hash: 10394f89685a7268c9d5813407a368e4
  orphan hash: e3d6f297103512b699a05292f7d6b08d
  flag hash: 4a197e670d605e4f8ceeb5c4aaae358a
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Properties.install_a
  Properties.install_b
  Properties.install_c
  Properties.install_c'
  Properties.install_d
  Properties.InstallProp
module dependencies:
package dependencies: appm-0.0.0 base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: appm-0.0.0:Utils base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  appm-0.0.0:Defs c8776ec9639bd8739e47c30a97e82c26
import  -/  appm-0.0.0:Utils 64658fcf41d296a2e90c8c567eb8db7b
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
8eb93717f770944c027113d8552b212c
  $s$fEq(,) :: GHC.Classes.Eq (Defs.PName, Defs.Version)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Defs.PName, Defs.Version)
                  (GHC.Classes.$fEq(,)_$c==
                     @ Defs.PName
                     @ Defs.Version
                     Defs.$fEqPName
                     Defs.$fEqVersion)
                  Properties.$s$fEq(,)_$s$fEq(,)_$c/= -}
6f918acafe98e3795e45a860ca8b7c78
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    (Defs.PName, Defs.Version)
    -> (Defs.PName, Defs.Version) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (Defs.PName, Defs.Version))
                   (y :: (Defs.PName, Defs.Version)) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Base.eqString
                        a1 `cast` (Defs.N:PName[0])
                        b1 `cast` (Defs.N:PName[0]) of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ Defs.VNum
                             Defs.$fEqVNum
                             a2 `cast` (Defs.N:Version[0])
                             b2 `cast` (Defs.N:Version[0]) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
23f548d8a1a8a3b641b4b01ca7aff91c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Properties.$trModule3
                   Properties.$trModule1) -}
94ab8ab05e7d1d69e746f8b88e53c1f5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Properties.$trModule2) -}
68189f52d26313406c23546685959720
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Properties"#) -}
f74bedf00513bc08a55d755e65614825
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Properties.$trModule4) -}
026c81296e1caea95bdf421041a68f0c
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
d955852428c5063099d8258415042df5
  $winstall_a ::
    Defs.Database -> GHC.Base.Maybe Defs.Sol -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Defs.Database)
                   (w1 :: GHC.Base.Maybe Defs.Sol) ->
                 case w1 of wild {
                   GHC.Base.Nothing -> GHC.Types.True
                   GHC.Base.Just ipv
                   -> let {
                        ds :: [(Defs.PName, Defs.Version)]
                        = GHC.Base.map
                            @ Defs.Pkg
                            @ (Defs.PName, Defs.Version)
                            Utils.getNameVerList1
                            w `cast` (Defs.N:Database[0])
                      } in
                      letrec {
                        go :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [(Defs.PName, Defs.Version)]) ->
                          case ds1 of wild1 {
                            [] -> GHC.Types.True
                            : y ys
                            -> case GHC.List.elem
                                      @ (Defs.PName, Defs.Version)
                                      Properties.$s$fEq(,)
                                      y
                                      ds of wild2 {
                                 GHC.Types.False -> GHC.Types.False GHC.Types.True -> go ys } }
                      } in
                      go ipv }) -}
929c250f62977fd52be73f021d3ca131
  $winstall_d ::
    Defs.Database -> GHC.Base.Maybe Defs.Sol -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Defs.Database)
                   (w1 :: GHC.Base.Maybe Defs.Sol) ->
                 case w1 of wild {
                   GHC.Base.Nothing -> GHC.Types.True
                   GHC.Base.Just ds
                   -> case ds of wild1 {
                        [] -> GHC.Types.True
                        : ipv ipv1
                        -> case ipv of wild2 { (,) n v ->
                           let {
                             $w$j :: Defs.Constrs -> GHC.Types.Bool
                               <join 1> {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                             = \ (ww :: Defs.Constrs)[OneShot] ->
                               letrec {
                                 go :: [(Defs.PName, Defs.Version, Defs.Version)] -> GHC.Types.Bool
                                   <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                 = \ (ds1 :: [(Defs.PName, Defs.Version, Defs.Version)]) ->
                                   case ds1 of wild3 {
                                     [] -> GHC.Types.True
                                     : y ys
                                     -> case y of wild4 { (,,) n1 lo hi ->
                                        let {
                                          exit :: GHC.Types.Bool <join 0> = go ys
                                        } in
                                        letrec {
                                          go1 :: [(Defs.PName, Defs.Version)] -> GHC.Types.Bool
                                            <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                          = \ (ds2 :: [(Defs.PName, Defs.Version)]) ->
                                            case ds2 of wild5 {
                                              [] -> GHC.Types.False
                                              : y1 ys1
                                              -> case y1 of wild6 { (,) pn v1 ->
                                                 case GHC.Base.eqString
                                                        pn `cast` (Defs.N:PName[0])
                                                        n1 `cast` (Defs.N:PName[0]) of wild7 {
                                                   GHC.Types.False -> go1 ys1
                                                   GHC.Types.True
                                                   -> case Utils.$fOrdVersion_$c<= lo v1 of wild8 {
                                                        GHC.Types.False -> go1 ys1
                                                        GHC.Types.True
                                                        -> case GHC.Classes.$fEq[]_$c==
                                                                  @ Defs.VNum
                                                                  Defs.$fEqVNum
                                                                  v1 `cast` (Defs.N:Version[0])
                                                                  hi
                                                                    `cast`
                                                                  (Defs.N:Version[0]) of wild9 {
                                                             GHC.Types.False
                                                             -> case Utils.$fOrdVersion_$c<=
                                                                       v1
                                                                       hi of wild10 {
                                                                  GHC.Types.False -> go1 ys1
                                                                  GHC.Types.True -> exit }
                                                             GHC.Types.True -> go1 ys1 } } } } }
                                        } in
                                        go1 ipv1 } }
                               } in
                               go (Utils.requirementsOf_go ww)
                           } in
                           letrec {
                             go :: [Defs.Pkg] -> GHC.Types.Bool
                               <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds1 :: [Defs.Pkg]) ->
                               case ds1 of wild3 {
                                 [] -> GHC.Types.False
                                 : y ys
                                 -> case y of wild4 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                                    case GHC.Base.eqString
                                           ds4 `cast` (Defs.N:PName[0])
                                           n `cast` (Defs.N:PName[0]) of wild5 {
                                      GHC.Types.False -> go ys
                                      GHC.Types.True
                                      -> case GHC.Classes.$fEq[]_$c==
                                                @ Defs.VNum
                                                Defs.$fEqVNum
                                                ds5 `cast` (Defs.N:Version[0])
                                                v `cast` (Defs.N:Version[0]) of wild6 {
                                           GHC.Types.False -> go ys
                                           GHC.Types.True -> $w$j ds7 } } } }
                           } in
                           go w `cast` (Defs.N:Database[0]) } } }) -}
9e9f2bedba9ef176dfeb6837ad9eac02
  type InstallProp =
    Defs.Database
    -> Defs.PName -> GHC.Base.Maybe Defs.Sol -> GHC.Types.Bool
ba78bbc351d111d7f79ba4d8c5643780
  install_a :: Properties.InstallProp
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><L,A><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: Defs.Database)
                   (w1 :: Defs.PName)
                   (w2 :: GHC.Base.Maybe Defs.Sol) ->
                 Properties.$winstall_a w w2) -}
ff988e9293e11ea962b9c04132b1d489
  install_b :: Properties.InstallProp
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: Defs.Database)
                   (ds1 :: Defs.PName)
                   (ds2 :: GHC.Base.Maybe Defs.Sol) ->
                 case ds2 of wild {
                   GHC.Base.Nothing -> GHC.Types.True
                   GHC.Base.Just s -> Utils.allDiff s }) -}
92a60ab9fcd04964df3dba94213ef9ef
  install_c :: Properties.InstallProp
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ (db :: Defs.Database)
                   (p :: Defs.PName)
                   (ds :: GHC.Base.Maybe Defs.Sol) ->
                 case Utils.ofSomeVersionIn p db of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just ds1 -> GHC.Types.True }) -}
20d15cb3016aa4569e00471f1c397b9f
  install_c' :: Properties.InstallProp
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (_db :: Defs.Database)
                   (_p :: Defs.PName)
                   (ds :: GHC.Base.Maybe Defs.Sol) ->
                 case ds of wild {
                   GHC.Base.Nothing -> GHC.Types.True
                   GHC.Base.Just ds1
                   -> case ds1 of wild1 {
                        [] -> GHC.Types.False : ipv ipv1 -> GHC.Types.True } }) -}
1fd3fad5e8e07f9503e9d65a8abb5312
  install_d :: Properties.InstallProp
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><L,A><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: Defs.Database)
                   (w1 :: Defs.PName)
                   (w2 :: GHC.Base.Maybe Defs.Sol) ->
                 Properties.$winstall_d w w2) -}
"SPEC/Properties $fEq(,) @ PName @ Version" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                     Defs.Version)
                                                            (v :: GHC.Classes.Eq Defs.PName)
  GHC.Classes.$fEq(,) @ Defs.PName @ Defs.Version v v1
  = Properties.$s$fEq(,)
"SPEC/Properties $fEq(,)_$c/= @ PName @ Version" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                             Defs.Version)
                                                                 ($dEq :: GHC.Classes.Eq Defs.PName)
  GHC.Classes.$fEq(,)_$c/= @ Defs.PName @ Defs.Version $dEq $dEq1
  = Properties.$s$fEq(,)_$s$fEq(,)_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

