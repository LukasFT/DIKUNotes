
==================== FINAL INTERFACE ====================
2018-11-08 19:01:49.512763793 UTC

interface main:SolverImpl 8043
  interface hash: cfd25244db3b123c430bbe5a01a281bb
  ABI hash: 5bd5da36be845c98d6bfc5388ad42675
  export-list hash: 6db768706507fb66b01693ad3467dc94
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8159db7c32bdb9b5583c3379f950f8b0
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  SolverImpl.doesntConflictWith
  SolverImpl.findConsistentPackage
  SolverImpl.findDuplicatePackages
  SolverImpl.install
  SolverImpl.isConsistentDB
  SolverImpl.isRequiredBy
  SolverImpl.normalize
  SolverImpl.parseFile
  SolverImpl.pkgCompare
  SolverImpl.reqsAndConfs
  SolverImpl.runSolver
  SolverImpl.solve
  SolverImpl.solve'
  SolverImpl.sorted
module dependencies: Defs Parser ParserImpl Utils
package dependencies: array-0.5.2.0 base-4.11.1.0* binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 mtl-2.2.2 parsec-3.1.13.0
                      text-1.2.3.0 transformers-0.5.5.0
orphans: main:Utils text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.IO 1d5542cc02075c5e948018bfacea89c1
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.IO 1c239be44126f7b1ba512ea61300f4dc
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  Defs 939981403a64797c8d0fa3fbf484bbbe
  exports: c7af33238562f604e2baaf89a4270987
  Constrs 67ed1f0cbb9f7e339ca293c38a21e465
  DB b49c7dbde0a8d4b21e98f928363a906f
  Database 55a55788ca8541f4ef74a862bab369c7
  ErrMsg 832e4b49f39f830e3fa7575301a38b17
  P fb951bf22272dc815176dbb7d70b3c59
  PConstr 3682d99f4b17fea3ed26cf03606b04f4
  PName 4511359dbcf04214c85540a57fb65f09
  Pkg 517307a9ca3c1f5e46b542ebf261be96
  Sol 16e05ea27be6e36e50158e24b50ca6e0
  deps 517307a9ca3c1f5e46b542ebf261be96
  desc 517307a9ca3c1f5e46b542ebf261be96
  maxV ef16dd26544871705521bcddfc1705ab
  minV 63de5a4614bf01c8a49a2b5f89a01481
  name 517307a9ca3c1f5e46b542ebf261be96
  ver 517307a9ca3c1f5e46b542ebf261be96
import  -/  Parser 04c3b7cbab1c32f58bbf574715c1ccfb
  exports: e594bc1c3376ad36ae01ac9a8de010ad
import  -/  ParserImpl 4887397e8c1308768cab8b8c4a8291f0
  parseDatabase 691a12af14be8d0bd219ef96b9c4c173
import  -/  Utils 7cf83227e593a77bfd11340782384c6f
  exports: 1a5cae1c4720889ee4d936faefb0e28b
  merge 8ad095fb645d08fd1e1f2c792fa95af7
  satisfies e893c3b79a06ee7589b6795fc84a5c57
4677c26903e63285b1ea32b0a95e70e9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SolverImpl.$trModule3
                   SolverImpl.$trModule1) -}
5bcb6dc59d5418f38f537ca64260c9b2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SolverImpl.$trModule2) -}
6674b64506a6d729be87951f14258caa
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SolverImpl"#) -}
9dd2b6df88b8c7f23b56736858075d7c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SolverImpl.$trModule4) -}
1b845544c8621e2bcbfbf253975dac06
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
9cf90d665d631e7b005058f6052ca8d2
  $wgo ::
    [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
    -> (# [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))],
          [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
18d726871feb9c38cc0ca8e5d64feeba
  $wisRequiredBy ::
    Defs.Pkg
    -> Defs.PName
    -> GHC.Types.Bool
    -> Defs.Version
    -> Defs.Version
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*U,U,A,A)><L,1*U><S,1*U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Defs.Pkg)
                   (ww :: Defs.PName)
                   (ww1 :: GHC.Types.Bool)
                   (ww2 :: Defs.Version)
                   (ww3 :: Defs.Version) ->
                 case ww1 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case w of wild1 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                      case GHC.Base.eqString
                             ds4 `cast` (Defs.N:PName[0])
                             ww `cast` (Defs.N:PName[0]) of wild2 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case Utils.$fOrdVersion_$c<= ww2 ds5 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> Utils.$fOrdVersion_$c< ds5 ww3 } } } }) -}
61ae4f3a97401b8438fa5d1c7edf40a4
  $wpkgCompare :: Defs.Version -> Defs.Version -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: Defs.Version) (ww1 :: Defs.Version) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Defs.VNum
                        Defs.$fEqVNum
                        ww1 `cast` (Defs.N:Version[0])
                        ww `cast` (Defs.N:Version[0]) of wild {
                   GHC.Types.False
                   -> case Utils.$fOrdVersion_$c<= ww1 ww of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.LT }
                   GHC.Types.True -> GHC.Types.EQ }) -}
7e9cd7d1257ff9c6a11b13fadb97a247
  doesntConflictWith :: Defs.Pkg -> Defs.Constrs -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A,A)><S,1*U>,
     Unfolding: (\ (p :: Defs.Pkg) (c :: Defs.Constrs) ->
                 let {
                   v :: Defs.Version
                   = case p of wild { Defs.Pkg ds4 ds5 ds6 ds7 -> ds5 }
                 } in
                 let {
                   pn :: Defs.PName
                   = case p of wild { Defs.Pkg ds4 ds5 ds6 ds7 -> ds4 }
                 } in
                 letrec {
                   go1 :: [(Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))]
                          -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Defs.PName,
                                (GHC.Types.Bool, Defs.Version, Defs.Version))]) ->
                     case ds of wild {
                       [] -> GHC.Types.True
                       : y ys
                       -> case y of wild1 { (,) n ds1 ->
                          case ds1 of wild2 { (,,) b lo hi ->
                          let {
                            ds2 :: GHC.Types.Bool <join 0> = go1 ys
                          } in
                          case GHC.Base.eqString
                                 pn `cast` (Defs.N:PName[0])
                                 n `cast` (Defs.N:PName[0]) of wild3 {
                            GHC.Types.False -> ds2
                            GHC.Types.True
                            -> let {
                                 $j :: GHC.Types.Bool <join 0>
                                 = case b of wild4 {
                                     GHC.Types.False -> GHC.Types.False GHC.Types.True -> ds2 }
                               } in
                               let {
                                 $j1 :: GHC.Types.Bool <join 0>
                                 = case GHC.Classes.$fEq[]_$c==
                                          @ Defs.VNum
                                          Defs.$fEqVNum
                                          v `cast` (Defs.N:Version[0])
                                          hi `cast` (Defs.N:Version[0]) of wild4 {
                                     GHC.Types.False
                                     -> case Utils.$fOrdVersion_$c<= v hi of wild5 {
                                          GHC.Types.False -> $j GHC.Types.True -> ds2 }
                                     GHC.Types.True -> $j }
                               } in
                               case GHC.Classes.$fEq[]_$c==
                                      @ Defs.VNum
                                      Defs.$fEqVNum
                                      lo `cast` (Defs.N:Version[0])
                                      v `cast` (Defs.N:Version[0]) of wild4 {
                                 GHC.Types.False
                                 -> case Utils.$fOrdVersion_$c<= lo v of wild5 {
                                      GHC.Types.False -> $j GHC.Types.True -> $j1 }
                                 GHC.Types.True -> $j1 } } } } }
                 } in
                 go1 c) -}
5b04c1a3f59c5e37a7ed7257b740b775
  findConsistentPackage ::
    Defs.Pkg -> [Defs.Pkg] -> GHC.Base.Maybe Defs.Pkg
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U,U,U)><S,1*U> -}
928c3f55485d5f459cf1703bbd478b00
  findDuplicatePackages :: Defs.Pkg -> [Defs.Pkg] -> [Defs.Pkg]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U,A,A)><S,1*U>,
     Unfolding: (\ (p :: Defs.Pkg) (eta :: [Defs.Pkg]) ->
                 GHC.List.filter
                   @ Defs.Pkg
                   (\ (pkg :: Defs.Pkg) ->
                    case pkg of wild { Defs.Pkg ds4 ds5 ds6 ds7 ->
                    case p of wild1 { Defs.Pkg ds1 ds2 ds3 ds10 ->
                    case GHC.Base.eqString
                           ds4 `cast` (Defs.N:PName[0])
                           ds1 `cast` (Defs.N:PName[0]) of wild2 {
                      GHC.Types.False -> GHC.Types.False
                      GHC.Types.True
                      -> GHC.Classes.$fEq[]_$c==
                           @ Defs.VNum
                           Defs.$fEqVNum
                           ds5 `cast` (Defs.N:Version[0])
                           ds2 `cast` (Defs.N:Version[0]) } } })
                   eta) -}
8746f81082eba7042ac449f4288ec4f3
  install :: Defs.Database -> Defs.PName -> GHC.Base.Maybe Defs.Sol
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (ds :: Defs.Database) (pname :: Defs.PName) ->
                 let {
                   exit :: GHC.Base.Maybe Defs.Sol <join 0>
                   = case SolverImpl.$wgo
                            (GHC.Types.:
                               @ (Defs.PName, Defs.PConstr)
                               (pname, SolverImpl.install1)
                               (GHC.Types.[]
                                  @ (Defs.PName, Defs.PConstr))) of ww { (#,#) ww1 ww2 ->
                     case SolverImpl.solve'
                            ds
                            ww1
                            ww2
                            (GHC.Types.[] @ (Defs.PName, Defs.Version)) of wild {
                       [] -> GHC.Base.Nothing @ Defs.Sol
                       : ipv ipv1 -> GHC.Base.Just @ Defs.Sol ipv } }
                 } in
                 letrec {
                   go1 :: [Defs.Pkg] -> GHC.Base.Maybe Defs.Sol
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds1 :: [Defs.Pkg]) ->
                     case ds1 of wild {
                       [] -> GHC.Base.Nothing @ Defs.Sol
                       : y ys
                       -> case y of wild1 { Defs.Pkg ds4 ds5 ds6 ds7 ->
                          case GHC.Base.eqString
                                 ds4 `cast` (Defs.N:PName[0])
                                 pname `cast` (Defs.N:PName[0]) of wild2 {
                            GHC.Types.False -> go1 ys GHC.Types.True -> exit } } }
                 } in
                 go1 ds `cast` (Defs.N:Database[0])) -}
de5c865df486216c63cb1aed0264dab8
  install1 :: (GHC.Types.Bool, Defs.Version, Defs.Version)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Types.True,
                  Defs.minV1 `cast` (Sym (Defs.N:Version[0])),
                  Defs.maxV1 `cast` (Sym (Defs.N:Version[0])))) -}
a92d519b0a5bd680962034345dfce089
  isConsistentDB ::
    Defs.Database -> Data.Either.Either GHC.Base.String Defs.Database
  {- Arity: 1, Strictness: <S,1*U> -}
2d5f9073ee837a6eb4ba270eac7a2223
  isRequiredBy ::
    Defs.Pkg -> (Defs.PName, Defs.PConstr) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U,U,A,A)><S(LS(SLL)),1*U(1*U,1*U(1*U,1*U,U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: (Defs.PName, Defs.PConstr)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { (,,) ww4 ww5 ww6 ->
                 SolverImpl.$wisRequiredBy w ww1 ww4 ww5 ww6 } }) -}
3762f9f19140dba47d900da4d3af1631
  normalize ::
    Defs.Database -> Data.Either.Either GHC.Base.String Defs.Database
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Defs.Database) ->
                 case ds `cast` (Defs.N:Database[0]) of wild {
                   [] -> SolverImpl.normalize1
                   : ipv ipv1
                   -> SolverImpl.isConsistentDB
                        (Data.OldList.sortBy @ Defs.Pkg SolverImpl.pkgCompare wild)
                          `cast`
                        (Sym (Defs.N:Database[0])) }) -}
2a32dd853fc95822b3534fd270c847f7
  normalize1 :: Data.Either.Either GHC.Base.String Defs.Database
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Data.Either.Right
                   @ GHC.Base.String
                   @ Defs.Database
                   (GHC.Types.[] @ Defs.Pkg) `cast` (Sym (Defs.N:Database[0]))) -}
c43564ed0a9a230baa8d5c05ed56f431
  parseFile ::
    GHC.IO.FilePath
    -> GHC.Types.IO (Data.Either.Either Defs.ErrMsg Defs.Database)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.parseFile1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Either.Either Defs.ErrMsg Defs.Database>_R)) -}
c16cb98ef67ead6b423115bdfeb969b4
  parseFile1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either Defs.ErrMsg Defs.Database #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (path :: GHC.IO.FilePath)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        path
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds { (#,#) ipv2 ipv3 ->
                 (# ipv2, ParserImpl.parseDatabase ipv3 #) } }) -}
43da3b0bffbf19632b8d14d8cd4aba96
  pkgCompare :: Defs.Pkg -> Defs.Pkg -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSLL),1*U(A,U,A,A)><S(LSLL),1*U(A,U,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Defs.Pkg) (w1 :: Defs.Pkg) ->
                 case w of ww { Defs.Pkg ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Defs.Pkg ww6 ww7 ww8 ww9 ->
                 SolverImpl.$wpkgCompare ww2 ww7 } }) -}
b40d12bcc0d48eba27431a813f5a8826
  reqsAndConfs :: Defs.Constrs -> (Defs.Constrs, Defs.Constrs)
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Data.OldList.partition
                   @ (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
                   SolverImpl.reqsAndConfs1) -}
0c935f5bce86fb2c4d441add23a85e12
  reqsAndConfs1 ::
    (Defs.PName, (GHC.Types.Bool, Defs.Version, Defs.Version))
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(SLL)),1*U(A,1*U(1*U,A,A))>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Defs.PName,
                           (GHC.Types.Bool, Defs.Version, Defs.Version))) ->
                 case ds of wild { (,) ds1 ds2 ->
                 case ds2 of wild1 { (,,) bool ds3 ds4 -> bool } }) -}
6cf66e1cc0220f233bde1b67b4e99f28
  runSolver ::
    [GHC.Types.Char] -> GHC.Base.String -> GHC.Types.IO [Defs.Sol]
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.runSolver1
                  `cast`
                (<[GHC.Types.Char]>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <[Defs.Sol]>_R)) -}
5853ffb8a656c8dc30dedf51871c826c
  runSolver1 ::
    [GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [Defs.Sol] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (test :: [GHC.Types.Char])
                   (pkg :: GHC.Base.String)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        (GHC.CString.unpackAppendCString# SolverImpl.runSolver3 test)
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds { (#,#) ipv2 ipv3 ->
                 case (Text.Parsec.Prim.runPT
                         @ GHC.Base.String
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ Defs.Database
                         (ParserImpl.$s$fStream[]mtok @ GHC.Types.Char)
                         ParserImpl.databaseParser1
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <[GHC.Types.Char]>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <Defs.Database>_R))
                         GHC.Tuple.()
                         (GHC.Types.[] @ GHC.Types.Char)
                         ipv3)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError Defs.Database>_R) of wild {
                   Data.Either.Left err
                   -> SolverImpl.runSolver2 `cast` (GHC.Types.N:IO[0] <[Defs.Sol]>_R)
                        ipv2
                   Data.Either.Right db
                   -> case db `cast` (Defs.N:Database[0]) of wild1 {
                        []
                        -> (# ipv2,
                              case SolverImpl.$wgo
                                     (GHC.Types.:
                                        @ (Defs.PName, Defs.PConstr)
                                        (pkg `cast` (Sym (Defs.N:PName[0])), SolverImpl.install1)
                                        (GHC.Types.[]
                                           @ (Defs.PName, Defs.PConstr))) of ww { (#,#) ww1 ww2 ->
                              SolverImpl.solve'
                                (GHC.Types.[] @ Defs.Pkg) `cast` (Sym (Defs.N:Database[0]))
                                ww1
                                ww2
                                (GHC.Types.[] @ (Defs.PName, Defs.Version)) } #)
                        : ipv4 ipv5
                        -> case SolverImpl.isConsistentDB
                                  (Data.OldList.sortBy @ Defs.Pkg SolverImpl.pkgCompare wild1)
                                    `cast`
                                  (Sym (Defs.N:Database[0])) of wild2 {
                             Data.Either.Left ipv6
                             -> SolverImpl.runSolver2 `cast` (GHC.Types.N:IO[0] <[Defs.Sol]>_R)
                                  ipv2
                             Data.Either.Right ndb
                             -> (# ipv2,
                                   case SolverImpl.$wgo
                                          (GHC.Types.:
                                             @ (Defs.PName, Defs.PConstr)
                                             (pkg `cast` (Sym (Defs.N:PName[0])),
                                              SolverImpl.install1)
                                             (GHC.Types.[]
                                                @ (Defs.PName,
                                                   Defs.PConstr))) of ww { (#,#) ww1 ww2 ->
                                   SolverImpl.solve'
                                     ndb
                                     ww1
                                     ww2
                                     (GHC.Types.[] @ (Defs.PName, Defs.Version)) } #) } } } } }) -}
1e431ecc6de861c5a4c078167e458f43
  runSolver2 :: GHC.Types.IO [Defs.Sol]
  {- Unfolding: (GHC.Magic.noinline
                   @ (forall a. [GHC.Types.Char] -> GHC.Types.IO a)
                   GHC.IO.failIO1
                     `cast`
                   (forall (a :: <*>_N).
                    <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R))
                   @ [Defs.Sol]
                   (GHC.Types.[] @ GHC.Types.Char)) -}
984b59ce96a5b30821841f12dd90f67b
  runSolver3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("../tests/BB/testfiles/"#) -}
066298a89d4d898878e1bea9eaa9f373
  solve :: Defs.Database -> Defs.Constrs -> Defs.Sol -> [Defs.Sol]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (db :: Defs.Database)
                   (c :: Defs.Constrs)
                   (sol :: Defs.Sol) ->
                 case SolverImpl.$wgo c of ww { (#,#) ww1 ww2 ->
                 SolverImpl.solve' db ww1 ww2 sol }) -}
d40e44b431e74becd8e5250587bcccd4
  solve' ::
    Defs.Database
    -> Defs.Constrs -> Defs.Constrs -> Defs.Sol -> [Defs.Sol]
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,1*U><L,U><L,U> -}
0375ff10f258a01a043e3f07704464f9
  sorted :: Defs.Database -> Defs.Database
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SolverImpl.sorted1
                  `cast`
                (<Defs.Database>_R ->_R Sym (Defs.N:Database[0])) -}
fab9cd56a356e2d052edaa386681844b
  sorted1 :: Defs.Database -> [Defs.Pkg]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Defs.Database) ->
                 Data.OldList.sortBy
                   @ Defs.Pkg
                   SolverImpl.pkgCompare
                   ds `cast` (Defs.N:Database[0])) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

